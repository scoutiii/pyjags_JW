name: Build (sdist + wheel)

on:
  push:
    branches: [ main, master ]
  pull_request:
  workflow_dispatch:

jobs:
  build:
    name: Build on ${{ matrix.os }} / Python ${{ matrix.python-version }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-13]
        python-version: ["3.11", "3.12", "3.13"]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      # Clean untracked files/dirs so no cached venvs land in the sdist
      - name: Clean working tree (safety)
        shell: bash
        run: |
          set -euxo pipefail
          git clean -xdf

      - name: Install JAGS (micromamba)
        uses: mamba-org/setup-micromamba@v2
        with:
          environment-name: jags
          condarc: |
            channels:
              - conda-forge
              - defaults
          create-args: >-
            python=${{ matrix.python-version }}
            jags
            pkg-config

      # ---- sanity: verify JAGS is discoverable via pkg-config inside the env
      - name: Check JAGS via pkg-config (sanity)
        shell: bash {0}
        run: |
          set -euxo pipefail
          micromamba run -n jags bash -lc '
            which pkg-config
            pkg-config --modversion jags
            pkg-config --cflags --libs jags
            echo "CONDA_PREFIX=$CONDA_PREFIX"
          '

      # ---- build sdist + wheel INSIDE the micromamba env
      - name: Build sdist + wheel (inside env, verbose)
        shell: bash {0}
        run: |
          set -euxo pipefail
          micromamba run -n jags bash -lc '
            # help CMake/pkg-config locate JAGS in this env
            export PKG_CONFIG_PATH="$CONDA_PREFIX/lib/pkgconfig"
            export CMAKE_PREFIX_PATH="$CONDA_PREFIX"
            export CPPFLAGS="-I$CONDA_PREFIX/include ${CPPFLAGS:-}"
            export LDFLAGS="-L$CONDA_PREFIX/lib ${LDFLAGS:-}"
            python -m pip install -U pip build
            python -m build
            ls -l dist
            test -n "$(ls dist/*.whl 2>/dev/null)" || { echo "No wheel built"; exit 1; }
          '

      # ---- Linux: repair wheels with auditwheel (still inside the env so libjags is visible)
      - name: Repair wheel (Linux)
        if: runner.os == 'Linux'
        shell: bash {0}
        run: |
          set -euxo pipefail
          micromamba run -n jags bash -lc '
            export LD_LIBRARY_PATH="$CONDA_PREFIX/lib:${LD_LIBRARY_PATH:-}"
            python -m pip install -U auditwheel
            for whl in dist/*.whl; do
              echo "== auditwheel show =="
              auditwheel show "$whl" || true
              echo "== auditwheel repair =="
              auditwheel repair -w wheelhouse "$whl"
            done
            ls -l wheelhouse || true
          '

      # ---- macOS: delocate to vendor libjags.dylib into the wheel
      - name: Repair wheel (macOS)
        if: runner.os == 'macOS'
        shell: bash {0}
        run: |
          set -euxo pipefail
          micromamba run -n jags bash -lc '
            export DYLD_LIBRARY_PATH="$CONDA_PREFIX/lib:${DYLD_LIBRARY_PATH:-}"
            python -m pip install -U delocate
            echo "== deps before =="
            delocate-listdeps dist/*.whl || true
            echo "== delocate =="
            delocate-wheel --ignore-missing -w wheelhouse dist/*.whl
            echo "== deps after =="
            delocate-listdeps wheelhouse/*.whl || true
          '
      
      - name: Inspect wheel contents (must contain pyjags/console*.so)
        shell: bash {0}
        run: |
          set -euxo pipefail
          WHL="$(ls wheelhouse/*.whl 2>/dev/null || ls dist/*.whl | head -n1)"
          echo "Inspecting wheel: $WHL"
          python - <<'PY'
          import glob, zipfile
          whl = sorted(glob.glob("wheelhouse/*.whl") or glob.glob("dist/*.whl"))[-1]
          print("== WHEEL FILES ==")
          with zipfile.ZipFile(whl) as z:
              for p in sorted(z.namelist()):
                  print(p)
              has_ext = any(
                  p.startswith("pyjags/") and
                  p.split("/")[-1].startswith("console.") and
                  p.split("/")[-1].endswith((".so",".dylib",".pyd"))
                  for p in z.namelist()
              )
              print("has_ext:", has_ext)
              assert has_ext, "Wheel missing compiled extension pyjags/console*"
          PY

      # ---- Test the installed wheel like a user would (replaces "Sanity import test")
      - name: Run tests against installed wheel (no repo shadowing)
        env:
          PYTHONPATH: ""   # ensure current dir isn't implicitly on sys.path
        shell: bash {0}
        run: |
          set -euxo pipefail
          # fresh runtime venv outside conda/mamba
          python -m venv venv_rt
          source venv_rt/bin/activate
          unset CONDA_PREFIX CONDA_DEFAULT_ENV MAMBA_ROOT_PREFIX PKG_CONFIG_PATH DYLD_LIBRARY_PATH LD_LIBRARY_PATH
          python -m pip install -U pip pytest

          # prefer repaired wheels; fall back to dist if none
          whl="$(ls wheelhouse/*.whl 2>/dev/null || true)"
          if [ -z "$whl" ]; then whl="$(ls dist/*.whl | head -n1)"; fi
          python -m pip install "$whl"

          # --- prove we're importing the installed wheel, not the repo ---
          python - <<'PY'
          import os, sys, importlib.util as iu, pyjags
          pkg_dir = os.path.dirname(pyjags.__file__)
          print("pyjags FROM:", pkg_dir)
          spec = iu.find_spec("pyjags.console")
          print("console spec:", spec)
          ws = os.environ.get("GITHUB_WORKSPACE") or ""
          assert not pkg_dir.startswith(ws), f"Imported from repo checkout: {pkg_dir}"
          assert spec is not None and spec.origin and ("site-packages" in spec.origin or ".venv" in spec.origin), \
                f"console not found in installed package: {spec}"
          PY

          # --- run tests from a temp dir containing ONLY the tests ---
          tdir="$(mktemp -d)"
          if [ -d tests ]; then
            cp -a tests "$tdir"/
          else
            echo "No tests/ directory found"; ls -la; exit 1
          fi
          cd "$tdir"
          # (optional) print sys.path once
          python - <<'PY'
          import sys, pprint; pprint.pp(sys.path)
          PY
          # run the suite; fail fast on first error for cleaner logs
          python -m pytest -q --maxfail=1 -ra


      - name: Upload artifacts (repaired wheels + sdist)
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ matrix.os }}-py${{ matrix.python-version }}
          path: |
            wheelhouse/*.whl
            dist/*.tar.gz
          if-no-files-found: error
